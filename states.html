
<!DOCTYPE html>
<html lang="en">
    <head>
        <script type="text/javascript" src="https://d3js.org/d3.v3.min.js"></script>
        <meta charset="utf-8">
        <link href="res/favicon.ico" rel="icon" type="image/x-icon" />
        <link href='https://fonts.googleapis.com/css?family=Lato:300,400,600,700' rel='stylesheet' type='text/css' />
        <style type="text/css">
            html, body {
                width: 100%;
                height: 100%;
                margin: 0;
                border: 0;
                padding: 0;
                font-family: "Helvetica Neue", Helvetica, sans-serif;
                font-size: 14px;
                color: #333;
            }
            #stateSvg {
                width: 3000000px;
                height: 2000000px;
            }
            path:hover {
	            fill-opacity: 0.7;
            }
        </style>
    </head>
    <body>
        <svg width="3000000" height="2000000" id="stateSvg"></svg>
        <script type="text/javascript">
            let stateJson = {};
            // Mercator appears to give the most stable results
            // Significant arcs do appear where points are far apart (CA-US border and within the continental US)
            const stateProjection = d3.geo.mercator()
                .scale(1 << 17)
                .translate([1300000, 1250000]);
            let stateSvg = d3.select("#stateSvg");
            d3.json("res/gadm/states.json", (err, dat) => {
                if (err) throw err;
                stateJson = dat;
                stateRender();
            });
            let statePath = d3.geo.path()
                .projection(stateProjection)
            function stateRender() {
                stateSvg.selectAll("path")
                    .data(stateJson.features)
                    .enter()
                        .append("path")
                        .attr("d", statePath)
                        .attr("ISO_1", d => d.properties.ISO_1)
                        .style("stroke", "#aaa")
                        .style("stroke-width", "0.01")
                        .style("fill", "#0000FF")
                        .on("mouseover", d => console.log(d.properties.ISO_1));
                setTimeout(makeTestSuite, 200);
            }
            function makeTestSuite () {
                d3.csv("res/gadm/state_test.csv", (err, dat) => {
                    if (err) throw err;
                    readStates(dat);
                });
            }
            let testResult;
            function readStates (dat) {
                let misses = [];
                let APIInput = [];
                testResult = dat.map((loc, pos) => {
                    let testP = stateProjection([+loc.longitude, +loc.latitude]);
                    // Using window is massively faster than reprojection
                    // Looks hacky, but the result is the same
                    window.scrollTo(testP[0] - 100, testP[1] - 100);
                    // Grab central and run basic boundary detection
                    let isos = [document.elementFromPoint(100, 100)?.getAttribute("ISO_1"),
                                document.elementFromPoint( 50, 100)?.getAttribute("ISO_1"),
                                document.elementFromPoint(100,  50)?.getAttribute("ISO_1"),
                                document.elementFromPoint(150, 100)?.getAttribute("ISO_1"),
                                document.elementFromPoint(100, 150)?.getAttribute("ISO_1")];
                    // Find the first valid value
                    let ISO_1 = isos.find(d => !!d) ?? "";
                    // Check for boundaries and use API to verify the results
                    let is_eq = isos.find(d => !!d && d !== ISO_1) !== undefined;
                    // Apply lookups, default to empty string
                    loc.ISO_1 = isoMap[ISO_1] ?? ISO_1;
                    // Log failures
                    if (loc.ISO_1 == "" || !is_eq) { // 
                        misses.push(loc); // Object
                        APIInput.push({pos: pos, lat: +loc.latitude, lon: +loc.longitude});
                    }
                    return loc;
                });
                console.log("Misses & edge cases: " + misses.length + " of " + testResult.length, misses);
                console.log("Begin API validation of " + APIInput.length + " edge cases & misses");
                locationAPI(APIInput);
                return testResult;
            }
            async function locationAPI (points) {
                const ak = ("<5<ij;7j57<h9ghhf75>i>g;g=9f;=f:").split``.map(c => String.fromCharCode(c.charCodeAt() - 5)).join``;
                let rem = points.length;
                const urls = Object.fromEntries(points.map(p => ["https://api.opencagedata.com/geocode/v1/json?key=" + ak + "&q=" + encodeURIComponent(p.lat + "," + p.lon) + "&pretty=0&no_annotations=1", p.pos]));
                for (let url of Object.keys(urls)) {
                    const request = new XMLHttpRequest();
                    request.open('GET', url, true);
                    request.onload = function() {
                        rem--;
                        console.log(rem + " remain to check");
                        if (rem === 0) console.log("API Requests complete");
                        if (request.status === 200) {
                            const data = JSON.parse(request.responseText);
                            const stateCode = data.results[0].components["ISO_3166-2"] ? data.results[0].components["ISO_3166-2"][0] :
                                              data.results[0].components["ISO_3166-1_alpha-2"] + "-" + data.results[0].components.state_code;
                            const pos = urls[request.responseURL];
                            testResult[pos].ISO_1 = isoMap[stateCode] ?? stateCode;
                        } else if (request.status <= 500) {
                            const data = JSON.parse(request.responseText);
                            console.error('Error: ' + data.status.message);
                        } else {
                            console.log("Server error");
                        }
                    };
                    request.onerror = () => {
                        console.log("Unable to connect to server");
                        rem--;
                        if (rem === 0) console.log("API Requests complete");
                    };
                    request.send();
                }
            }
            let isoMap = {
                "JP-01":"JP-HKD",
                "JP-02":"JP-AMR",
                "JP-03":"JP-IWT",
                "JP-04":"JP-MYG",
                "JP-05":"JP-AKT",
                "JP-06":"JP-YMT",
                "JP-07":"JP-FKS",
                "JP-08":"JP-IBR",
                "JP-09":"JP-TCG",
                "JP-10":"JP-GUM",
                "JP-11":"JP-STM",
                "JP-12":"JP-CHB",
                "JP-13":"JP-TOK",
                "JP-14":"JP-KNG",
                "JP-15":"JP-NGT",
                "JP-16":"JP-TYM",
                "JP-17":"JP-ISK",
                "JP-18":"JP-FUK",
                "JP-19":"JP-YMN",
                "JP-20":"JP-NGN",
                "JP-21":"JP-GIF",
                "JP-22":"JP-SZO",
                "JP-23":"JP-ACH",
                "JP-24":"JP-MIE",
                "JP-25":"JP-SHG",
                "JP-26":"JP-KYT",
                "JP-27":"JP-OSK",
                "JP-28":"JP-HYG",
                "JP-29":"JP-NAR",
                "JP-30":"JP-WKY",
                "JP-31":"JP-TGR",
                "JP-32":"JP-SMN",
                "JP-33":"JP-OKY",
                "JP-34":"JP-HRS",
                "JP-35":"JP-YMG",
                "JP-36":"JP-TKS",
                "JP-37":"JP-KGW",
                "JP-38":"JP-EHM",
                "JP-39":"JP-KOC",
                "JP-40":"JP-FKK",
                "JP-41":"JP-SAG",
                "JP-42":"JP-NGS",
                "JP-43":"JP-KMM",
                "JP-44":"JP-OIT",
                "JP-45":"JP-MYZ",
                "JP-46":"JP-KGS",
                "JP-47":"JP-OKN",
                "NA":""
            }
        </script>
    </body>
</html>