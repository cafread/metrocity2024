
<!DOCTYPE html>
<html lang="en">
    <head>
        <script type="text/javascript" src="https://d3js.org/d3.v3.min.js"></script>
        <meta charset="utf-8">
        <link href="res/favicon.ico" rel="icon" type="image/x-icon" />
        <link href='https://fonts.googleapis.com/css?family=Lato:300,400,600,700' rel='stylesheet' type='text/css' />
        <style type="text/css">
            html, body {
                width: 100%;
                height: 100%;
                margin: 0;
                border: 0;
                padding: 0;
                font-family: "Helvetica Neue", Helvetica, sans-serif;
                font-size: 14px;
                color: #333;
            }
            #stateSvg {
                width: 3000000px;
                height: 2000000px;
            }
            path:hover {
	            fill-opacity: 0.7;
            }
        </style>
    </head>
    <body>
        <svg width="3000000" height="2000000" id="stateSvg"></svg>
        <script type="text/javascript" src="res/stateCorrs.js"></script>
        <script type="text/javascript">
            // Country read here
            
            let stateJson = {};
            // Mercator appears to give the most stable results
            // Significant arcs do appear where points are far apart (CA-US border and within the continental US)
            const stateProjection = d3.geo.mercator()
                .scale(1 << 17)
                .translate([1300000, 1250000]);
            let stateSvg = d3.select("#stateSvg");
            d3.json("res/gadm/states.json", (err, dat) => {
                if (err) throw err;
                stateJson = dat;
                stateRender();
            });
            let statePath = d3.geo.path()
                .projection(stateProjection)
            function stateRender() {
                stateSvg.selectAll("path")
                    .data(stateJson.features)
                    .enter()
                        .append("path")
                        .attr("d", statePath)
                        .attr("ISO_1", d => d.properties.ISO_1)
                        .style("stroke", "#aaa")
                        .style("stroke-width", "0.01")
                        .style("fill", "#0000FF")
                        .on("mouseover", d => console.log(d.properties.ISO_1));
                setTimeout(makeStateTestSuite, 200);
            }
            function makeStateTestSuite () {
                d3.csv("res/gadm/state_test.csv", (err, dat) => {
                    if (err) throw err;
                    readStates(dat, true);
                });
            }
            let stateTestResult;
            function readStates (dat, checkBoundaries=false) {
                let misses = [];
                let APIInput = [];
                stateTestResult = dat.map((loc, pos) => {
                    // Use cache where possible
                    let cacheKey = +loc.latitude + "%2C" + +loc.longitude;
                    if (stateCorrs.hasOwnProperty(cacheKey)) {
                        loc.ISO_1 = stateCorrs[cacheKey];
                        localStorage.setItem(cacheKey, stateCorrs[cacheKey]);
                        return loc;
                    } else if (localStorage.getItem(cacheKey)) {
                        loc.ISO_1 = localStorage.getItem(cacheKey);
                        return loc;
                    }
                    let testP = stateProjection([+loc.longitude, +loc.latitude]);
                    // Using window is massively faster than reprojection
                    // Looks hacky, but the result is the same
                    window.scrollTo(testP[0] - 100, testP[1] - 100);
                    let ISO_1 = "";
                    let is_eq = true;
                    if (checkBoundaries) {
                        // Basic boundary detection - increases runtime and memory usage
                        const isos = [
                            document.elementFromPoint(100, 100)?.getAttribute("ISO_1"),
                            document.elementFromPoint( 50, 100)?.getAttribute("ISO_1"),
                            document.elementFromPoint(100,  50)?.getAttribute("ISO_1"),
                            document.elementFromPoint(150, 100)?.getAttribute("ISO_1"),
                            document.elementFromPoint(100, 150)?.getAttribute("ISO_1")
                        ];
                        // Find the first valid value
                        ISO_1 = isos.find(d => !!d) ?? "";
                        // Check for boundaries and use API to verify the results
                        is_eq = isos.find(d => !!d && d !== ISO_1) == undefined && ISO_1 !== null;
                    } else {
                        ISO_1 = document.elementFromPoint(100, 100)?.getAttribute("ISO_1") ?? "";
                        if (ISO_1 === "") { // Check for nearby
                            const isos = [
                                document.elementFromPoint( 50, 100)?.getAttribute("ISO_1"),
                                document.elementFromPoint(100,  50)?.getAttribute("ISO_1"),
                                document.elementFromPoint(150, 100)?.getAttribute("ISO_1"),
                                document.elementFromPoint(100, 150)?.getAttribute("ISO_1")
                            ];
                            ISO_1 = isos.find(d => !!d) ?? "";
                            is_eq = isos.find(d => !!d && d !== ISO_1) == undefined;
                            // Cache the tricky ones
                            if (is_eq) localStorage.setItem(cacheKey, ISO_1);
                        }
                    }
                    // Apply lookups
                    loc.ISO_1 = stateIsoMap[ISO_1] ?? ISO_1;
                    // Handle failures & boundaries
                    if (loc.ISO_1 == "") {
                        misses.push(loc);
                        // Misses at the start as they are more important
                        APIInput.unshift({pos: pos, lat: +loc.latitude, lon: +loc.longitude});
                    } else if (checkBoundaries && !is_eq) {
                        APIInput.push({pos: pos, lat: +loc.latitude, lon: +loc.longitude});
                    }
                    return loc;
                });
                let logStr  = "Misses: " + misses.length;
                    logStr += checkBoundaries ? ", boundary cases: " + (APIInput.length - misses.length) : "";
                    logStr += " of " + stateTestResult.length;
                console.log(logStr, misses, APIInput);
                console.log("Begin API validation of " + APIInput.length + " cases");
                stateLocAPI(APIInput);
                return stateTestResult;
            }
            const stoStateKey = (url) => url.slice(84).split("&")[0];
            let apiResult = [];
            async function stateLocAPI (points) {
                const ak = ("<5<ij;7j57<h9ghhf75>i>g;g=9f;=f:").split``.map(c => String.fromCharCode(c.charCodeAt() - 5)).join``;
                const urls = Object.fromEntries(points.map(p => ["https://api.opencagedata.com/geocode/v1/json?key=" + ak + "&q=" + encodeURIComponent(p.lat + "," + p.lon) + "&pretty=0&no_annotations=1", p.pos]));
                let rem = Object.keys(urls).length;
                let limitExceeded = false;
                for (let url of Object.keys(urls)) {
                    if (limitExceeded) break;
                    // Try cache first
                    // Should load some known to cache to begin with
                    if (localStorage.getItem(stoStateKey(url))) {
                        let stateCode = localStorage.getItem(stoStateKey(url));
                        const pos = urls[url];
                        stateTestResult[pos].ISO_1 = stateCode;
                        rem--;
                        console.log(rem + " remain to check");
                        continue;
                    }
                    const request = new XMLHttpRequest();
                    request.open('GET', url, true);
                    request.onload = function() {
                        rem--;
                        console.log(rem + " remain to check");
                        if (rem <= 0) console.log("API Requests complete");
                        if (request.status === 402) {
                            limitExceeded = true;
                            rem = 0;
                            console.log("API limit exceeded, terminating");
                        } else if (request.status === 200) {
                            const data = JSON.parse(request.responseText);
                            let stateCode = data.results[0].components["ISO_3166-2"] ? data.results[0].components["ISO_3166-2"][0] :
                                            data.results[0].components["ISO_3166-1_alpha-2"] + "-" + data.results[0].components.state_code;
                            const pos = urls[request.responseURL];
                            stateCode = stateIsoMap[stateCode] ?? stateCode;
                            stateTestResult[pos].ISO_1 = stateCode;
                            // Cache result
                            const lsKey = stoStateKey(request.responseURL);
                            apiResult.push([lsKey, stateCode]);
                            localStorage.setItem(lsKey, stateCode);
                        } else if (request.status <= 500) {
                            const data = JSON.parse(request.responseText);
                            console.error('Error: ' + data.status.message);
                        } else {
                            console.log("Server error");
                        }
                    };
                    request.onerror = () => {
                        console.log("Unable to connect to server");
                        rem--;
                        if (rem <= 0) console.log("API Requests complete");
                    };
                    request.send();
                }
            }
            
            // MC Read here
            
            // Remap to our preferred codes for Japan
            let stateIsoMap = {
                "JP-01":"JP-HKD",
                "JP-02":"JP-AMR",
                "JP-03":"JP-IWT",
                "JP-04":"JP-MYG",
                "JP-05":"JP-AKT",
                "JP-06":"JP-YMT",
                "JP-07":"JP-FKS",
                "JP-08":"JP-IBR",
                "JP-09":"JP-TCG",
                "JP-10":"JP-GUM",
                "JP-11":"JP-STM",
                "JP-12":"JP-CHB",
                "JP-13":"JP-TOK",
                "JP-14":"JP-KNG",
                "JP-15":"JP-NGT",
                "JP-16":"JP-TYM",
                "JP-17":"JP-ISK",
                "JP-18":"JP-FUK",
                "JP-19":"JP-YMN",
                "JP-20":"JP-NGN",
                "JP-21":"JP-GIF",
                "JP-22":"JP-SZO",
                "JP-23":"JP-ACH",
                "JP-24":"JP-MIE",
                "JP-25":"JP-SHG",
                "JP-26":"JP-KYT",
                "JP-27":"JP-OSK",
                "JP-28":"JP-HYG",
                "JP-29":"JP-NAR",
                "JP-30":"JP-WKY",
                "JP-31":"JP-TGR",
                "JP-32":"JP-SMN",
                "JP-33":"JP-OKY",
                "JP-34":"JP-HRS",
                "JP-35":"JP-YMG",
                "JP-36":"JP-TKS",
                "JP-37":"JP-KGW",
                "JP-38":"JP-EHM",
                "JP-39":"JP-KOC",
                "JP-40":"JP-FKK",
                "JP-41":"JP-SAG",
                "JP-42":"JP-NGS",
                "JP-43":"JP-KMM",
                "JP-44":"JP-OIT",
                "JP-45":"JP-MYZ",
                "JP-46":"JP-KGS",
                "JP-47":"JP-OKN",
                "NA":""
            }
        </script>
    </body>
</html>